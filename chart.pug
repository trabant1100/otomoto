mixin chart(id, scale, chronos, fn)
	svg(class='priceChart', viewBox=`-${scale.xMargin} 0 ${scale.date + scale.xMargin * 2} ${scale.price + 10}`)
		-
			var chronos = fn.normalizeChronos(scale, chronos)
			var chronosPoints = [{ x: 0, y: scale.price - chronos[0].chartPrice }]
				.concat(
					Array.from(chronos.entries())
						.map(([i, s]) => {
							const next = chronos[i+1];
							const offset = next && s.chartPrice != next?.chartPrice 
								? (next?.chartDate - s.chartDate - 2) 
								: 0;
							return { x: s.chartDate + offset, y: scale.price - s.chartPrice };
						}))
			var svgPoints = chronosPoints
				.map(p => `${p.x},${p.y}`)
			var fillPoints = chronosPoints
				.concat([
					{ x: scale.date, y: scale.price },
					{ x: 0, y: scale.price }
				])
				.map(p => `${p.x},${p.y}`)
		defs
			linearGradient(id=`fillGradient${id}`, gradientTransform='rotate(90)')
				stop(offset='0%', stop-color='var(--price-bg-color)')
				stop(offset='50%', stop-color='var(--price-bg-color)')
				stop(offset='100%', stop-color='white')
		g.background
			line(x1=0, y1=scale.price, x2=scale.date, y2=scale.price, class='axisDate')
			polygon(points=fillPoints.join(' '), fill=`url(#fillGradient${id})`)
		- var priceInfos = fn.calculatePriceInfos(chronosPoints, chronos, scale)
		each priceInfo, priceInfoIndex in priceInfos
			- var index = priceInfo.index
			- var priceChangeIndex = priceInfo.priceChangeIndex
			- var point = priceInfo.point
			- var nextPoint = priceInfos[priceInfoIndex + 1]?.point ?? { x: Number.MAX_VALUE, y: point.y }
			- var points = priceInfo.points
			- var trans = priceInfo.trans
			- var priceWidth = priceInfo.priceWidth
			- var price = priceInfo.price
			g.price
				polygon(points=points.map(p => `${p.x},${p.y}`).join(' '), tabindex=-1)
				polyline(points=points.filter(p => p.y != scale.price).map(p => `${p.x},${p.y}`).join(' '))
				g.priceInfo(transform=`translate(${trans.x}, ${trans.y})`)
					rect(x=point.x, y=point.y, width=priceWidth, height=10, rx=2)
					text(x=point.x + priceWidth / 2 - 0.4, y=point.y + 6, text-anchor='middle' dominant-baseline='middle')
						| #{price}
			g.dateInfo
				- var date = fn.parseDate(chronos[index ? index - 1 : 0].date)
				- var textAnchor = index ? 'middle' : 'start'
				- var dist = nextPoint.x - point.x
				line.date(x1=point.x, y1=scale.price, x2=point.x, y2=scale.price + 3)
				if dist >= 10
					text(x=point.x, y=scale.price + 4, text-anchor=textAnchor, dominant-baseline='hanging', class='date')
						| #{new Intl.DateTimeFormat('pl-PL', { day: 'numeric', month: 'short' }).format(date)}
		